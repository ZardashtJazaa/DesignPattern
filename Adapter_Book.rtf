{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /// There are cases where we have use a type that. Doesn't fit well into the rest of software systems, situations like this accrue when we use code that we dont own like for example, Third party libraries or legacy code , we can't modify anything in the incompatible interface , but we dont want refactor our existing code either .. so how can we make the incompatible interface work with the rest of code (The adapter pattern come to rescue) in this typical implementation it wraps the object to be adapted and exposes the interface(class,struct) that families to the callers .\
\
Adapter: Wraps an incomplete type and exposes an interface that's familiar to the caller \
Adapter in swift: -> easy to implement using type extensions \
\
The callers doesn't know at all that we are relaying  \
========\
In swift we can implement Adapter pattern without creating a new wrapper (type) using type extensions. , The type extensions is powerful future , that allows adding protocol conformance to a type without modifying its source code , we can even enhance built-in and third party types , whose code is inaccessible for us.}